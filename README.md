# 설계 결정 사항 및 고려 사항

## 1. ODM (Object Data Mapper) 선택: Mongoose

본 프로젝트에서는 NestJS와 MongoDB를 연동하기 위한 ODM으로 **Mongoose**를 선택했습니다. 주요 이유는 다음과 같습니다.

*   **NestJS와의 뛰어난 통합성:** `@nestjs/mongoose` 패키지를 통해 NestJS 애플리케이션에 Mongoose를 매우 쉽고 효율적으로 통합할 수 있습니다. 모듈, 서비스, 프로바이더 등 NestJS의 핵심 개념들과 자연스럽게 어우러집니다.
*   **스키마 기반 모델링:** Mongoose는 스키마를 사용하여 데이터 모델을 정의하고, 각 필드의 타입, 기본값, 유효성 검사 규칙 등을 명시적으로 관리할 수 있게 해줍니다. 이는 TypeScript의 정적 타이핑과 잘 부합하며, 개발 초기 단계부터 데이터의 일관성과 무결성을 확보하는 데 도움을 줍니다.
*   **강력한 쿼리 빌더 및 유틸리티:** 복잡한 쿼리 작성, 데이터 populate (참조된 문서 로드), 미들웨어 (pre/post hooks), 가상 필드(virtuals) 등 개발 생산성을 높여주는 다양한 기능을 제공합니다.
*   **풍부한 커뮤니티와 자료:** Mongoose는 Node.js 환경에서 MongoDB를 사용하는 가장 대중적인 라이브러리 중 하나로, 방대한 커뮤니티와 수많은 레퍼런스 자료를 보유하고 있어 문제 해결 및 학습에 용이합니다.
*   **유연한 스키마 설계 지원:** 이벤트 조건이나 보상 내용과 같이 변경 가능성이 높고 다양한 형태를 가질 수 있는 데이터에 대해 `Mixed` 타입이나 유연한 객체 구조를 스키마 내에 정의할 수 있어, Q&A에서 언급된 "자유로운 이벤트/보상 정의" 요구사항을 충족시키기 적합합니다.

*대안으로 MikroORM도 고려되었으나, MongoDB와의 직접적인 연동 편의성, NestJS 생태계에서의 일반적인 사용 빈도, 그리고 Mongoose가 제공하는 스키마 중심의 개발 방식이 본 프로젝트의 특성에 더 부합한다고 판단했습니다.*

## 2. MSA 환경에서의 데이터 일관성

본 프로젝트는 Gateway Server, Auth Server, Event Server로 구성된 마이크로서비스 아키텍처(MSA)를 따릅니다. MSA 환경에서는 각 서비스가 독립적인 데이터 저장소를 가지므로 데이터 일관성 유지가 중요한 고려 사항입니다.

*   **서비스 간 데이터 소유권 명확화:**
    *   `Auth Server`: 사용자 계정 정보(ID, 역할 등)에 대한 소유권을 가집니다.
    *   `Event Server`: 이벤트, 보상, 사용자의 보상 요청 내역에 대한 소유권을 가집니다.
    *   각 서비스는 자신의 데이터베이스에만 직접 접근하며, 다른 서비스의 데이터는 API 호출을 통해 동기화하거나 ID를 참조하여 사용합니다.

*   **일관성 수준:**
    *   **최종 일관성 (Eventual Consistency):** 대부분의 경우 최종 일관성 모델을 따릅니다. 예를 들어, 사용자가 `Auth Server`에서 생성된 후, 해당 사용자 정보가 `Event Server`에서 즉시 보이지 않을 수 있지만, 결국에는 동기화되어 일관성을 유지합니다. 이벤트 목록 조회나 보상 내역 조회 등은 최종 일관성으로 충분히 처리 가능합니다.
    *   **강한 일관성 (Strong Consistency) 필요 지점:**
        *   **보상 지급 처리:** 사용자가 보상을 요청하고 시스템이 조건 충족 여부를 검증한 후 실제 보상을 지급(또는 지급 상태를 변경)하는 로직은 단일 `Event Server` 내에서 트랜잭션과 유사한 방식으로 처리되어야 합니다. 예를 들어, 보상 수량 차감과 사용자 요청 상태 변경은 원자적으로 이루어져야 중복 지급이나 데이터 불일치 문제를 방지할 수 있습니다. MongoDB는 단일 문서 연산에 대해서는 원자성을 보장하며, 여러 문서에 걸친 트랜잭션은 MongoDB 4.0 이상부터 지원됩니다. 상황에 따라 이를 활용하거나, 애플리케이션 레벨에서 상태 관리와 보상 로직을 신중하게 설계하여 일관성을 확보해야 합니다.
        *   **중복 보상 요청 방지:** `Event Server`는 특정 사용자가 특정 이벤트에 대해 이미 보상을 요청했는지 여부를 정확히 확인하고 중복 요청을 막아야 합니다. 이는 `(userId, eventId)` 조합에 대한 고유 인덱스 설정 및 요청 처리 로직에서 강한 일관성을 필요로 합니다.

*   **서비스 간 통신:** 서비스 간 데이터 동기화나 요청은 비동기 메시징 (예: Kafka, RabbitMQ - 과제 범위 초과 시 단순 API 호출) 또는 동기 API 호출을 사용할 수 있습니다. 본 과제에서는 복잡성을 고려하여 주로 동기 API 호출(Gateway를 통한) 방식을 기본으로 하되, 필요에 따라 특정 이벤트 발생 시 다른 서비스에 알리는 방식(예: 웹훅 또는 간단한 이벤트 발행)을 고려할 수 있습니다.

## 3. 보안 및 감사

민감한 데이터를 다루고, 사용자에게 실질적인 보상이 지급되는 시스템이므로 보안 및 감사 기능은 매우 중요합니다.

*   **인증 및 권한 부여:**
    *   모든 API 요청은 `Gateway Server`를 통해 JWT 기반으로 인증됩니다.
    *   `Auth Server`에서 발급된 JWT에는 사용자의 역할(USER, OPERATOR, AUDITOR, ADMIN) 정보가 포함되며, `Gateway Server`는 이를 기반으로 각 엔드포인트에 대한 접근 권한을 엄격하게 제어합니다 (`RolesGuard` 활용).

*   **데이터 보안:**
    *   **민감 정보 최소화:** 사용자 비밀번호와 같은 민감 정보는 `Auth Server`에서 안전하게 해시 처리되어 저장됩니다.
    *   **입력값 검증:** `class-validator`를 사용한 DTO 유효성 검사와 Mongoose 스키마 레벨 유효성 검사를 통해 악의적인 입력이나 잘못된 데이터로부터 시스템을 보호합니다.
    *   **API 속도 제한 (Rate Limiting):** (선택 사항, 실제 프로덕션 고려) 과도한 요청으로 인한 서비스 장애를 방지하기 위해 `Gateway Server`에 API 속도 제한을 적용할 수 있습니다.

*   **감사 추적 (Auditing):**
    *   **보상 지급 내역:** "감사 담당자는 지급 내역만 조회할 수 있어야 한다"는 요구사항에 따라, `EventRewardRequest` 컬렉션(또는 유사한 이름의 컬렉션)에 보상 요청 및 처리와 관련된 모든 중요한 정보를 기록합니다.
        *   `userId` (요청한 사용자)
        *   `eventId` (관련 이벤트)
        *   `rewardId` (지급된 보상 - 실제 보상 내용 참조)
        *   `requestedAt` (요청 시간)
        *   `processedAt` (처리 시간)
        *   `status` (요청 상태: PENDING, SUCCESS, FAILED, REVIEW_PENDING 등)
        *   `processor` (처리 주체: 'SYSTEM' 또는 운영자 ID)
        *   `details` (실패 사유, 검토 내용 등 추가 정보)
    *   **타임스탬프:** Mongoose 스키마의 `timestamps: true` 옵션을 활성화하여 모든 주요 데이터 (이벤트 생성/수정, 보상 등록/수정, 요청 생성/수정 등)의 `createdAt`과 `updatedAt`을 자동으로 기록하여 변경 이력을 추적합니다.
    *   **운영자 활동 로그 (선택 사항, 확장 고려):** 이벤트 생성/수정, 보상 등록/수정 등 운영자의 주요 활동에 대해서도 별도의 로그를 기록하여 시스템 변경 사항을 추적하고 문제 발생 시 원인 파악을 용이하게 할 수 있습니다.

이러한 고민들은 시스템의 안정성, 확장성, 유지보수성을 높이고, "실제 프로덕션에서 이 코드를 돌려도 될까?"라는 질문에 긍정적으로 답하기 위한 노력의 일환입니다.